"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveFiles = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const crypto_1 = require("crypto");
/**
 * Saves multiple {@link CodegenFile}s.
 */
async function saveFiles(opts) {
    const { toolName = "ts-poet", directory = "./", files, toStringOpts = {} } = opts;
    await Promise.all(files.map(async (file) => {
        const path = `${directory}/${file.name}`;
        // We might be writing to a subdirectory, so check this for each file
        await fs_1.promises.mkdir((0, path_1.dirname)(path), { recursive: true });
        const exists = await trueIfResolved(fs_1.promises.access(path));
        if (file.overwrite) {
            if (!file.hash) {
                // Just write the file w/o the hash hint (i.e. for JSON/etc)
                await fs_1.promises.writeFile(path, contentToString(file, toStringOpts));
            }
            else {
                // Create a hash of the unformatted option (to avoid the cost of formatting)
                const hash = sha1(contentToString(file, { ...toStringOpts, format: false }));
                if (exists) {
                    const existing = (await fs_1.promises.readFile(path)).toString();
                    const match = existing.match(/\(hash=([0-9a-z]+)\)/);
                    if (match && match[1] === hash)
                        return;
                }
                // Now write the formatted out, but tagged with the unformatted version
                await fs_1.promises.writeFile(path, `// Generated by ${toolName} (hash=${hash})\n` + contentToString(file, toStringOpts));
            }
        }
        else if (!exists) {
            await fs_1.promises.writeFile(path, contentToString(file, {}));
        }
    }));
}
exports.saveFiles = saveFiles;
function contentToString(file, toStringOpts) {
    var _a;
    if (typeof file.contents === "string") {
        return file.contents;
    }
    // Do a lazy/by-hand deep merge of toStringOpts and file.toStringOpts
    return file.contents.toString({
        path: file.name,
        ...toStringOpts,
        ...file.toStringOpts,
        dprintOptions: {
            ...toStringOpts.dprintOptions,
            ...(_a = file.toStringOpts) === null || _a === void 0 ? void 0 : _a.dprintOptions,
        },
    });
}
// We purposefully use sha1 for speed b/c this isn't for crypto/auth
function sha1(content) {
    const sum = (0, crypto_1.createHash)("sha1");
    sum.update(content);
    return sum.digest("hex").substring(0, 6);
}
/** Returns true if `p` is resolved, otherwise false if it is rejected. */
async function trueIfResolved(p) {
    return p.then(() => true, () => false);
}
