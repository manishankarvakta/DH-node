"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PushMessageContent_GroupContext = exports.PushMessageContent_AttachmentPointer = exports.PushMessageContent = exports.IncomingPushMessageSignal = exports.PushMessageContent_GroupContext_Type = exports.PushMessageContent_Flags = exports.IncomingPushMessageSignal_Type = void 0;
const minimal_1 = require("protobufjs/minimal");
const baseIncomingPushMessageSignal = {
    type: 0,
    source: "",
    sourceDevice: 0,
    relay: "",
    timestamp: 0,
};
const basePushMessageContent = {
    body: "",
    flags: 0,
};
const basePushMessageContent_AttachmentPointer = {
    id: 0,
    contentType: "",
};
const basePushMessageContent_GroupContext = {
    type: 0,
    name: "",
    members: "",
};
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
exports.IncomingPushMessageSignal_Type = {
    UNKNOWN: 0,
    CIPHERTEXT: 1,
    KEY_EXCHANGE: 2,
    PREKEY_BUNDLE: 3,
    PLAINTEXT: 4,
    RECEIPT: 5,
    PREKEY_BUNDLE_DEVICE_CONTROL: 6,
    DEVICE_CONTROL: 7,
    UNRECOGNIZED: -1,
    fromJSON(object) {
        switch (object) {
            case 0:
            case "UNKNOWN":
                return exports.IncomingPushMessageSignal_Type.UNKNOWN;
            case 1:
            case "CIPHERTEXT":
                return exports.IncomingPushMessageSignal_Type.CIPHERTEXT;
            case 2:
            case "KEY_EXCHANGE":
                return exports.IncomingPushMessageSignal_Type.KEY_EXCHANGE;
            case 3:
            case "PREKEY_BUNDLE":
                return exports.IncomingPushMessageSignal_Type.PREKEY_BUNDLE;
            case 4:
            case "PLAINTEXT":
                return exports.IncomingPushMessageSignal_Type.PLAINTEXT;
            case 5:
            case "RECEIPT":
                return exports.IncomingPushMessageSignal_Type.RECEIPT;
            case 6:
            case "PREKEY_BUNDLE_DEVICE_CONTROL":
                return exports.IncomingPushMessageSignal_Type.PREKEY_BUNDLE_DEVICE_CONTROL;
            case 7:
            case "DEVICE_CONTROL":
                return exports.IncomingPushMessageSignal_Type.DEVICE_CONTROL;
            case -1:
            case "UNRECOGNIZED":
            default:
                return exports.IncomingPushMessageSignal_Type.UNRECOGNIZED;
        }
    },
    toJSON(object) {
        switch (object) {
            case exports.IncomingPushMessageSignal_Type.UNKNOWN:
                return "UNKNOWN";
            case exports.IncomingPushMessageSignal_Type.CIPHERTEXT:
                return "CIPHERTEXT";
            case exports.IncomingPushMessageSignal_Type.KEY_EXCHANGE:
                return "KEY_EXCHANGE";
            case exports.IncomingPushMessageSignal_Type.PREKEY_BUNDLE:
                return "PREKEY_BUNDLE";
            case exports.IncomingPushMessageSignal_Type.PLAINTEXT:
                return "PLAINTEXT";
            case exports.IncomingPushMessageSignal_Type.RECEIPT:
                return "RECEIPT";
            case exports.IncomingPushMessageSignal_Type.PREKEY_BUNDLE_DEVICE_CONTROL:
                return "PREKEY_BUNDLE_DEVICE_CONTROL";
            case exports.IncomingPushMessageSignal_Type.DEVICE_CONTROL:
                return "DEVICE_CONTROL";
            default:
                return "UNKNOWN";
        }
    },
};
exports.PushMessageContent_Flags = {
    END_SESSION: 1,
    UNRECOGNIZED: -1,
    fromJSON(object) {
        switch (object) {
            case 1:
            case "END_SESSION":
                return exports.PushMessageContent_Flags.END_SESSION;
            case -1:
            case "UNRECOGNIZED":
            default:
                return exports.PushMessageContent_Flags.UNRECOGNIZED;
        }
    },
    toJSON(object) {
        switch (object) {
            case exports.PushMessageContent_Flags.END_SESSION:
                return "END_SESSION";
            default:
                return "UNKNOWN";
        }
    },
};
exports.PushMessageContent_GroupContext_Type = {
    UNKNOWN: 0,
    UPDATE: 1,
    DELIVER: 2,
    QUIT: 3,
    UNRECOGNIZED: -1,
    fromJSON(object) {
        switch (object) {
            case 0:
            case "UNKNOWN":
                return exports.PushMessageContent_GroupContext_Type.UNKNOWN;
            case 1:
            case "UPDATE":
                return exports.PushMessageContent_GroupContext_Type.UPDATE;
            case 2:
            case "DELIVER":
                return exports.PushMessageContent_GroupContext_Type.DELIVER;
            case 3:
            case "QUIT":
                return exports.PushMessageContent_GroupContext_Type.QUIT;
            case -1:
            case "UNRECOGNIZED":
            default:
                return exports.PushMessageContent_GroupContext_Type.UNRECOGNIZED;
        }
    },
    toJSON(object) {
        switch (object) {
            case exports.PushMessageContent_GroupContext_Type.UNKNOWN:
                return "UNKNOWN";
            case exports.PushMessageContent_GroupContext_Type.UPDATE:
                return "UPDATE";
            case exports.PushMessageContent_GroupContext_Type.DELIVER:
                return "DELIVER";
            case exports.PushMessageContent_GroupContext_Type.QUIT:
                return "QUIT";
            default:
                return "UNKNOWN";
        }
    },
};
exports.IncomingPushMessageSignal = {
    encode(message, writer = minimal_1.Writer.create()) {
        writer.uint32(8).int32(message.type);
        writer.uint32(18).string(message.source);
        writer.uint32(56).uint32(message.sourceDevice);
        writer.uint32(26).string(message.relay);
        writer.uint32(40).uint64(message.timestamp);
        writer.uint32(50).bytes(message.message);
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseIncomingPushMessageSignal);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.source = reader.string();
                    break;
                case 7:
                    message.sourceDevice = reader.uint32();
                    break;
                case 3:
                    message.relay = reader.string();
                    break;
                case 5:
                    message.timestamp = longToNumber(reader.uint64());
                    break;
                case 6:
                    message.message = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseIncomingPushMessageSignal);
        if (object.type !== undefined && object.type !== null) {
            message.type = exports.IncomingPushMessageSignal_Type.fromJSON(object.type);
        }
        else {
            message.type = 0;
        }
        if (object.source !== undefined && object.source !== null) {
            message.source = String(object.source);
        }
        else {
            message.source = "";
        }
        if (object.sourceDevice !== undefined && object.sourceDevice !== null) {
            message.sourceDevice = Number(object.sourceDevice);
        }
        else {
            message.sourceDevice = 0;
        }
        if (object.relay !== undefined && object.relay !== null) {
            message.relay = String(object.relay);
        }
        else {
            message.relay = "";
        }
        if (object.timestamp !== undefined && object.timestamp !== null) {
            message.timestamp = Number(object.timestamp);
        }
        else {
            message.timestamp = 0;
        }
        if (object.message !== undefined && object.message !== null) {
            message.message = bytesFromBase64(object.message);
        }
        return message;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseIncomingPushMessageSignal);
        if (object.type !== undefined && object.type !== null) {
            message.type = object.type;
        }
        else {
            message.type = 0;
        }
        if (object.source !== undefined && object.source !== null) {
            message.source = object.source;
        }
        else {
            message.source = "";
        }
        if (object.sourceDevice !== undefined && object.sourceDevice !== null) {
            message.sourceDevice = object.sourceDevice;
        }
        else {
            message.sourceDevice = 0;
        }
        if (object.relay !== undefined && object.relay !== null) {
            message.relay = object.relay;
        }
        else {
            message.relay = "";
        }
        if (object.timestamp !== undefined && object.timestamp !== null) {
            message.timestamp = object.timestamp;
        }
        else {
            message.timestamp = 0;
        }
        if (object.message !== undefined && object.message !== null) {
            message.message = object.message;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        obj.type = exports.IncomingPushMessageSignal_Type.toJSON(message.type);
        obj.source = message.source || "";
        obj.sourceDevice = message.sourceDevice || 0;
        obj.relay = message.relay || "";
        obj.timestamp = message.timestamp || 0;
        obj.message = message.message !== undefined ? base64FromBytes(message.message) : undefined;
        return obj;
    },
};
exports.PushMessageContent = {
    encode(message, writer = minimal_1.Writer.create()) {
        writer.uint32(10).string(message.body);
        for (const v of message.attachments) {
            exports.PushMessageContent_AttachmentPointer.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.group !== undefined && message.group !== undefined) {
            exports.PushMessageContent_GroupContext.encode(message.group, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(32).uint32(message.flags);
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePushMessageContent);
        message.attachments = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.body = reader.string();
                    break;
                case 2:
                    message.attachments.push(exports.PushMessageContent_AttachmentPointer.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.group = exports.PushMessageContent_GroupContext.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.flags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, basePushMessageContent);
        message.attachments = [];
        if (object.body !== undefined && object.body !== null) {
            message.body = String(object.body);
        }
        else {
            message.body = "";
        }
        if (object.attachments !== undefined && object.attachments !== null) {
            for (const e of object.attachments) {
                message.attachments.push(exports.PushMessageContent_AttachmentPointer.fromJSON(e));
            }
        }
        if (object.group !== undefined && object.group !== null) {
            message.group = exports.PushMessageContent_GroupContext.fromJSON(object.group);
        }
        else {
            message.group = undefined;
        }
        if (object.flags !== undefined && object.flags !== null) {
            message.flags = Number(object.flags);
        }
        else {
            message.flags = 0;
        }
        return message;
    },
    fromPartial(object) {
        const message = Object.assign({}, basePushMessageContent);
        message.attachments = [];
        if (object.body !== undefined && object.body !== null) {
            message.body = object.body;
        }
        else {
            message.body = "";
        }
        if (object.attachments !== undefined && object.attachments !== null) {
            for (const e of object.attachments) {
                message.attachments.push(exports.PushMessageContent_AttachmentPointer.fromPartial(e));
            }
        }
        if (object.group !== undefined && object.group !== null) {
            message.group = exports.PushMessageContent_GroupContext.fromPartial(object.group);
        }
        else {
            message.group = undefined;
        }
        if (object.flags !== undefined && object.flags !== null) {
            message.flags = object.flags;
        }
        else {
            message.flags = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        obj.body = message.body || "";
        if (message.attachments) {
            obj.attachments = message.attachments.map(e => e ? exports.PushMessageContent_AttachmentPointer.toJSON(e) : undefined);
        }
        else {
            obj.attachments = [];
        }
        obj.group = message.group ? exports.PushMessageContent_GroupContext.toJSON(message.group) : undefined;
        obj.flags = message.flags || 0;
        return obj;
    },
};
exports.PushMessageContent_AttachmentPointer = {
    encode(message, writer = minimal_1.Writer.create()) {
        writer.uint32(9).fixed64(message.id);
        writer.uint32(18).string(message.contentType);
        writer.uint32(26).bytes(message.key);
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePushMessageContent_AttachmentPointer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = longToNumber(reader.fixed64());
                    break;
                case 2:
                    message.contentType = reader.string();
                    break;
                case 3:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, basePushMessageContent_AttachmentPointer);
        if (object.id !== undefined && object.id !== null) {
            message.id = Number(object.id);
        }
        else {
            message.id = 0;
        }
        if (object.contentType !== undefined && object.contentType !== null) {
            message.contentType = String(object.contentType);
        }
        else {
            message.contentType = "";
        }
        if (object.key !== undefined && object.key !== null) {
            message.key = bytesFromBase64(object.key);
        }
        return message;
    },
    fromPartial(object) {
        const message = Object.assign({}, basePushMessageContent_AttachmentPointer);
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        else {
            message.id = 0;
        }
        if (object.contentType !== undefined && object.contentType !== null) {
            message.contentType = object.contentType;
        }
        else {
            message.contentType = "";
        }
        if (object.key !== undefined && object.key !== null) {
            message.key = object.key;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        obj.id = message.id || 0;
        obj.contentType = message.contentType || "";
        obj.key = message.key !== undefined ? base64FromBytes(message.key) : undefined;
        return obj;
    },
};
exports.PushMessageContent_GroupContext = {
    encode(message, writer = minimal_1.Writer.create()) {
        writer.uint32(10).bytes(message.id);
        writer.uint32(16).int32(message.type);
        writer.uint32(26).string(message.name);
        for (const v of message.members) {
            writer.uint32(34).string(v);
        }
        if (message.avatar !== undefined && message.avatar !== undefined) {
            exports.PushMessageContent_AttachmentPointer.encode(message.avatar, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePushMessageContent_GroupContext);
        message.members = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.members.push(reader.string());
                    break;
                case 5:
                    message.avatar = exports.PushMessageContent_AttachmentPointer.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, basePushMessageContent_GroupContext);
        message.members = [];
        if (object.id !== undefined && object.id !== null) {
            message.id = bytesFromBase64(object.id);
        }
        if (object.type !== undefined && object.type !== null) {
            message.type = exports.PushMessageContent_GroupContext_Type.fromJSON(object.type);
        }
        else {
            message.type = 0;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.members !== undefined && object.members !== null) {
            for (const e of object.members) {
                message.members.push(String(e));
            }
        }
        if (object.avatar !== undefined && object.avatar !== null) {
            message.avatar = exports.PushMessageContent_AttachmentPointer.fromJSON(object.avatar);
        }
        else {
            message.avatar = undefined;
        }
        return message;
    },
    fromPartial(object) {
        const message = Object.assign({}, basePushMessageContent_GroupContext);
        message.members = [];
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        if (object.type !== undefined && object.type !== null) {
            message.type = object.type;
        }
        else {
            message.type = 0;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        else {
            message.name = "";
        }
        if (object.members !== undefined && object.members !== null) {
            for (const e of object.members) {
                message.members.push(e);
            }
        }
        if (object.avatar !== undefined && object.avatar !== null) {
            message.avatar = exports.PushMessageContent_AttachmentPointer.fromPartial(object.avatar);
        }
        else {
            message.avatar = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        obj.id = message.id !== undefined ? base64FromBytes(message.id) : undefined;
        obj.type = exports.PushMessageContent_GroupContext_Type.toJSON(message.type);
        obj.name = message.name || "";
        if (message.members) {
            obj.members = message.members.map(e => e || "");
        }
        else {
            obj.members = [];
        }
        obj.avatar = message.avatar ? exports.PushMessageContent_AttachmentPointer.toJSON(message.avatar) : undefined;
        return obj;
    },
};
const windowBase64 = globalThis;
const atob = windowBase64.atob || ((b64) => Buffer.from(b64, 'base64').toString('binary'));
const btoa = windowBase64.btoa || ((bin) => Buffer.from(bin, 'binary').toString('base64'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
function base64FromBytes(arr) {
    const bin = [];
    for (let i = 0; i < arr.byteLength; ++i) {
        bin.push(String.fromCharCode(arr[i]));
    }
    return btoa(bin.join(''));
}
