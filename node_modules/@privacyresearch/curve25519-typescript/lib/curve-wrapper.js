"use strict";
/*
 * Created April 2020
 *
 * Copyright (c) 2020 Privacy Research, LLC
 *
 *  Licensed under GPL v3 (https://www.gnu.org/licenses/gpl-3.0.en.html)
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncCurve25519Wrapper = exports.Curve25519Wrapper = void 0;
/// <reference types="emscripten" />
const curveasm_1 = __importDefault(require("./built/curveasm"));
const instancePromise = (0, curveasm_1.default)();
class Curve25519Wrapper {
    constructor(module) {
        this._module = module;
        this.basepoint = new Uint8Array(32).fill(0);
        this.basepoint[0] = 9;
    }
    static create() {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = yield instancePromise;
            return new Curve25519Wrapper(instance);
        });
    }
    _allocate(bytes) {
        const address = this._module._malloc(bytes.length);
        this._module.HEAPU8.set(bytes, address);
        return address;
    }
    _readBytes(address, length, array) {
        array.set(this._module.HEAPU8.subarray(address, address + length));
    }
    keyPair(privKey) {
        const priv = new Uint8Array(privKey);
        priv[0] &= 248;
        priv[31] &= 127;
        priv[31] |= 64;
        // Where to store the result
        const publicKey_ptr = this._module._malloc(32);
        // Get a pointer to the private key
        const privateKey_ptr = this._allocate(priv);
        // The basepoint for generating public keys
        const basepoint_ptr = this._allocate(this.basepoint);
        // The return value is just 0, the operation is done in place
        const err = this._module._curve25519_donna(publicKey_ptr, privateKey_ptr, basepoint_ptr);
        if (err !== 0) {
            throw new Error(`Error performing curve scalar multiplication: ${err}`);
        }
        const res = new Uint8Array(32);
        this._readBytes(publicKey_ptr, 32, res);
        this._module._free(publicKey_ptr);
        this._module._free(privateKey_ptr);
        this._module._free(basepoint_ptr);
        return { pubKey: res.buffer, privKey: priv.buffer };
    }
    sharedSecret(pubKey, privKey) {
        // Where to store the result
        const sharedKey_ptr = this._module._malloc(32);
        // Get a pointer to our private key
        const privateKey_ptr = this._allocate(new Uint8Array(privKey));
        // Get a pointer to their public key, the basepoint when you're
        // generating a shared secret
        const basepoint_ptr = this._allocate(new Uint8Array(pubKey));
        // Return value is 0 here too of course
        const err = this._module._curve25519_donna(sharedKey_ptr, privateKey_ptr, basepoint_ptr);
        if (err !== 0) {
            throw new Error(`Error performing curve scalar multiplication: ${err}`);
        }
        const res = new Uint8Array(32);
        this._readBytes(sharedKey_ptr, 32, res);
        this._module._free(sharedKey_ptr);
        this._module._free(privateKey_ptr);
        this._module._free(basepoint_ptr);
        return res.buffer;
    }
    sign(privKey, message) {
        // Where to store the result
        const signature_ptr = this._module._malloc(64);
        // Get a pointer to our private key
        const privateKey_ptr = this._allocate(new Uint8Array(privKey));
        // Get a pointer to the message
        const message_ptr = this._allocate(new Uint8Array(message));
        this._module._curve25519_sign(signature_ptr, privateKey_ptr, message_ptr, message.byteLength);
        const res = new Uint8Array(64);
        this._readBytes(signature_ptr, 64, res);
        this._module._free(signature_ptr);
        this._module._free(privateKey_ptr);
        this._module._free(message_ptr);
        return res.buffer;
    }
    verify(pubKey, message, sig) {
        // Get a pointer to their public key
        const publicKey_ptr = this._allocate(new Uint8Array(pubKey));
        // Get a pointer to the signature
        const signature_ptr = this._allocate(new Uint8Array(sig));
        // Get a pointer to the message
        const message_ptr = this._allocate(new Uint8Array(message));
        const res = this._module._curve25519_verify(signature_ptr, publicKey_ptr, message_ptr, message.byteLength);
        this._module._free(publicKey_ptr);
        this._module._free(signature_ptr);
        this._module._free(message_ptr);
        return res !== 0;
    }
    /**
     * Syntactic sugar for verify with explicit semantics.  The fact that verify returns true when
     * a signature is invalid could be confusing. The meaning of this function should be clear.
     *
     * @param pubKey
     * @param message
     * @param sig
     */
    signatureIsValid(pubKey, message, sig) {
        return !this.verify(pubKey, message, sig);
    }
}
exports.Curve25519Wrapper = Curve25519Wrapper;
class AsyncCurve25519Wrapper {
    constructor() {
        this.curvePromise = Curve25519Wrapper.create();
    }
    keyPair(privKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.curvePromise).keyPair(privKey);
        });
    }
    sharedSecret(pubKey, privKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.curvePromise).sharedSecret(pubKey, privKey);
        });
    }
    sign(privKey, message) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.curvePromise).sign(privKey, message);
        });
    }
    verify(pubKey, message, sig) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.curvePromise).verify(pubKey, message, sig);
        });
    }
}
exports.AsyncCurve25519Wrapper = AsyncCurve25519Wrapper;
